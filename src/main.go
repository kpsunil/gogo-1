package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"github.com/shivansh/gogo/src/codegen"
	"github.com/shivansh/gogo/src/parser"
	"github.com/shivansh/gogo/src/scanner"
	"github.com/shivansh/gogo/src/tac"
)

// GenToken generates the tokens returned by lexer from the input program.
func GenToken(file string) {
	scanner.PrintTokens(file)
}

// GenIR generates the IR instructions from the input program.
func GenIR(file string) {
	if err := parser.GenProductions(file); err != nil {
		fmt.Fprintf(os.Stderr, "%s", err)
		os.Exit(1)
	}
}

// GenAsmFromIR generates the assembly code using IR generated from the input program.
func GenAsmFromIR(file string) {
	// A journey of a thousand miles begins with a single step. This is that step.
	codegen.CodeGen(tac.GenTAC(file))
}

// GenAsm generates the assembly code from the input go program.
func GenAsm(file string) {
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w
	outChan := make(chan string)

	// Buffer the output generated by GenIR into a pipe. The output is
	// copied in a separate goroutine so that printing doesn't block.
	go func() {
		var buf bytes.Buffer
		if _, err := io.Copy(&buf, r); err != nil {
			log.Fatal(err)
		}
		outChan <- buf.String()
	}()

	GenIR(file)
	if err := w.Close(); err != nil {
		log.Fatal(err)
	}
	// Restore the original state (before pipe was created).
	os.Stdout = old
	ir := <-outChan

	// Create a temporary IR file which will be used to generate assembly.
	// TODO: Update function signatures to avoid I/O.
	irFile := "tmp.ir"
	f, err := os.Create(irFile)
	if err != nil {
		log.Fatal(err)
	}
	func() {
		if err := f.Close(); err != nil {
			log.Fatal(err)
		}
	}()
	writer := bufio.NewWriter(f)
	if _, err = writer.WriteString(ir); err != nil {
		log.Fatal(err)
	}
	if err := writer.Flush(); err != nil {
		log.Fatal(err)
	}

	GenAsmFromIR(irFile)
	if err = os.Remove(irFile); err != nil {
		log.Fatal(err)
	}
}

// GenHTML generates the rightmost derivations used in the bottom-up parsing and
// pretty-prints them in an HTML format.
func GenHTML(file string) error {
	return parser.RightmostDerivation(file)
}

func main() {
	asm := flag.Bool("s", false, "Generates MIPS assembly from go program")
	ir := flag.Bool("r", false, "Generates IR instructions from go program")
	ir2asm := flag.Bool("r2s", false, "Generates the MIPS assembly from IR")
	prod := flag.Bool("p", false, "Generates rightmost derivations used in bottom-up parsing")
	// optimize := flag.Bool("O", false, "Turn on optimizations")
	flag.Parse()

	args := os.Args
	if len(args) != 3 {
		fmt.Fprintf(os.Stderr, "Usage: gogo (-p | -r | -r2s | -s) <filename>\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	var err error
	if *asm {
		GenAsm(args[2])
	} else if *ir {
		GenIR(args[2])
	} else if *ir2asm {
		// TODO: Verify if the input is indeed in a valid IR format.
		GenAsmFromIR(args[2])
	} else if *prod {
		if err = GenHTML(args[2]); err == nil {
			index := strings.LastIndex(args[2], ".")
			genFileName := args[2][:index]
			fmt.Printf("Successfully created %s.html\n", genFileName)
		}
	}

	if err != nil {
		fmt.Fprintf(os.Stderr, "%s", err)
	}
}
