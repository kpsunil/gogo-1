// === [ Lexical part] =========================================================

terminator : ';' '\n' | ';' | '\n' ;

// --- [ Keywords ] ------------------------------------------------------------
kwdBreak    : 'b' 'r' 'e' 'a' 'k' ;
kwdCase     : 'c' 'a' 's' 'e' ;
kwdConst    : 'c' 'o' 'n' 's' 't' ;
kwdContinue : 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;
kwdDefault  : 'd' 'e' 'f' 'a' 'u' 'l' 't' ;
kwdElse     : 'e' 'l' 's' 'e' ;
kwdFunc     : 'f' 'u' 'n' 'c' ;
kwdFor      : 'f' 'o' 'r' ;
kwdGoto     : 'g' 'o' 't' 'o' ;
kwdIf       : 'i' 'f' ;
kwdImport   : 'i' 'm' 'p' 'o' 'r' 't' ;
kwdPackage  : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;
kwdRange    : 'r' 'a' 'n' 'g' 'e' ;
kwdRet      : 'r' 'e' 't' 'u' 'r' 'n' ;
kwdStruct   : 's' 't' 'r' 'u' 'c' 't' ;
kwdSwitch   : 's' 'w' 'i' 't' 'c' 'h' ;
kwdType     : 't' 'y' 'p' 'e' ;
kwdVar      : 'v' 'a' 'r' ;

// --- [ Types ] ---------------------------------------------------------------
type : 'b' 'o' 'o' 'l'
     | 'i' 'n' 't' | 'f' 'l' 'o' 'a' 't' '3' '2' | 'f' 'l' 'o' 'a' 't' '6' '4'
     | 'b' 'y' 't' 'e'
     | 's' 't' 'r' 'i' 'n' 'g'
     ;

// --- [ Predeclared constants ] -----------------------------------------------
boolLit : 't' 'r' 'u' 'e' | 'f' 'a' 'l' 's' 'e' ;

// --- [ Operators ] -----------------------------------------------------------
_relOp      : '=' '=' | '!' '=' | '<' | '<' '=' | '>' | '>' '=' ;
_addOp      : '+' | '-' | '|' | '^' ;
_mulOp      : '*' | '/' | '%' | '<' '<' | '>' '>' | '&' | '&' '^' ;
assignOp    : [ _addOp | _mulOp ] '=' ;
shortAssign : ':' '=' ;
// dotOp       : '.' ;

// --- [ Whitespaces (suppressed) ] --------------------------------------------
!whitespace : ' ' | '\t' | '\r' ;

// --- [ Comments (suppressed) ] -----------------------------------------------
!comment      : _lineComment | _blockComment ;
_lineComment  : '/' '/' { . } '\n' ;
_blockComment : '/' '*' { . | '*' } '*' '/' ;

// --- [ Letters and digits ] --------------------------------------------------
_letter        : _unicodeLetter | '_' ;
_unicodeLetter : 'a' - 'z' | 'A' - 'Z' ;
_decimalDigit  : '0' - '9' ;
_octalDigit    : '0' - '7' ;
_hexDigit      : _decimalDigit | 'a' - 'f' | 'A' - 'F' ;

// --- [ Identifiers ] ---------------------------------------------------------
// TODO: Check this
// blankIdent : '_' ;
identifier : _letter { _letter | _decimalDigit } ;

// --- [ Integer literals ] ----------------------------------------------------
intLit      : _decimalLit | _octalLit | _hexLit ;
_decimalLit : '1' - '9' { _decimalDigit } ;
_octalLit   : '0' { _octalDigit } ;
_hexLit     : '0' ( 'x' | 'X' ) _hexDigit { _hexDigit } ;

// --- [ Floating-point literals ] ---------------------------------------------
floatLit  : _decimals '.' [ _decimals ] [ _exponent ]
          | _decimals _exponent
          | '.' _decimals [ _exponent ]
          ;
_decimals : _decimalDigit { _decimalDigit } ;
_exponent : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

// --- [ String literals ] -----------------------------------------------------
stringLit          :  _rawStrLit | _interpretedStrLit ;
_rawStrLit         : '`' { . } '`' ;
_interpretedStrLit : '"' { . | '\\' '"' | _escapeChar } '"' ;

// --- [ Single-character escapes ] --------------------------------------------
_escapeChar : '\\' 'n' | '\\' 'r' | '\\' 't' ;

// --- [ Rune literals ] -------------------------------------------------------
runeLit  : '\'' [ '\\' ] [ . ] '\'' ;

// === [ Syntax part] ==========================================================

<<
import (
        "fmt"

        "github.com/shivansh/gogo/src/ast"
        "github.com/shivansh/gogo/tmp/token"
)
>>

// NOTE
//      - https://github.com/goccmack/gocc/issues/5998
//      - The commented production rules below are not supported yet.
//      - Before each production rule, the corresponding rules from the go
//        language specification are written in comments.

Start
        : SourceFile  << ast.PrintIR($0) >>
        ;

// SourceFile : PackageClause terminator RepeatTerminator RepeatImportDecl RepeatTopLevelDecl
SourceFile
        : RepeatTopLevelDecl  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

// RepeatImportDecl : ImportDecl terminator RepeatTerminator RepeatImportDecl
//                         << func() (Attrib, error) {
//                                 n := &Node{"", []string{}}
//                                 n.Code = append(n.Code, $0.(*ast.Node).Code...)
//                                 n.Code = append(n.Code, $3.(*ast.Node).Code...)
//                                 n.Code = append(n.Code, "\n")
//                                 return nil, nil
//                         } () >>
//                  | empty
//                         << func() (Attrib, error) {
//                                 n := &Node{"", []string{}}
//                                 return n, nil
//                         } () >>
//                  ;
//
// // ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
// // ImportSpec       = [ "." | PackageName ] ImportPath .
// // ImportPath       = string_lit .
// ImportDecl : kwdImport ImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdImport ImportSpec");
//                         return nil, nil
//                 } () >>
//            | kwdImport "(" RepeatImportSpec ")"
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdImport \"(\" RepeatImportSpec \")\"");
//                         return nil, nil
//                 } () >>
//            ;
//
// RepeatImportSpec : ImportSpec terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("ImportSpec terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
//                  | empty
//                 << func() (Attrib, error) {
//                         fmt.Println("empty");
//                         return nil, nil
//                 } () >>
//                 // TODO: '\n' can follow "import (", but a ';' cannot as opposed to go's grammar.
//                  | terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
//                  ;
//
// ImportSpec : ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("ImportPath");
//                         return nil, nil
//                 } () >>
//            | "." ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("\".\" ImportPath");
//                         return nil, nil
//                 } () >>
//            | PackageName ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("PackageName ImportPath");
//                         return nil, nil
//                 } () >>
//            ;
//
// ImportPath : stringLit
//                 << func() (Attrib, error) {
//                       fmt.Println("stringLit");
//                       return nil, nil
//                 } () >>
//            ;
//
// PackageClause : kwdPackage PackageName
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdPackage PackageName");
//                         return nil, nil
//                 } () >>
//               ;
//
// PackageName : identifier
//                 << func() (Attrib, error) {
//                         fmt.Println("identifier");
//                         return nil, nil
//                 } () >>
//             ;

// --- [ Top level declarations ] ----------------------------------------------

// TODO: MethodDecl is not supported at the moment.
// TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
RepeatTopLevelDecl
        : TopLevelDecl RepeatTopLevelDecl  << ast.NewTopLevelDecl($0, $1) >>
        | empty                            << ast.InitNode("", []string{}) >>
        ;

TopLevelDecl
        : Declaration RepeatTerminator   << ast.InitNode("", $0.(*ast.Node).Code) >>
        | FunctionDecl RepeatTerminator  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

// Declaration = ConstDecl | TypeDecl | VarDecl .
Declaration
        : ConstDecl  << ast.InitNode("", $0.(*ast.Node).Code) >>
        | TypeDecl   << ast.InitNode("", $0.(*ast.Node).Code) >>
        | VarDecl    << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

// --- [ Variable declarations ] -----------------------------------------------

// VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
// VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
VarDecl
        : kwdVar VarSpec  << ast.InitNode("", $1.(*ast.Node).Code) >>
//         | kwdVar "(" RepeatTerminator RepeatVarSpec ")"
//             << func() (Attrib, error) {
//                   fmt.Println("kwdVar \"(\" RepeatTerminator RepeatVarSpec \")\"");
//                   return nil, nil
//             } () >>
        ;

VarSpec
        : IdentifierList Type                     << ast.NewVarSpec(0, $0, $1) >>
        | IdentifierList Type "=" ExpressionList  << ast.NewVarSpec(1, $0, $1, $3) >>
        | IdentifierList "=" ExpressionList       << ast.NewVarSpec(2, $0, $2) >>
        | empty                                   << ast.NewVarSpec(3) >>
        ;

// --- [ Type declarations ] ---------------------------------------------------

// TypeDecl  = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
// TypeSpec  = AliasDecl | TypeDef .
// AliasDecl = identifier "=" Type
// TypeDef   = identifier Type
TypeDecl : kwdType TypeSpec   << ast.NewTypeDecl($0, $1) >>
//          | kwdType "(" RepeatTerminator RepeatTypeSpec ")"
         ;
//
// RepeatTypeSpec : TypeSpec terminator RepeatTerminator RepeatTypeSpec
//                     << func() (Attrib, error) {
//                             fmt.Println("TypeSpec terminator RepeatTerminator RepeatTypeSpec");
//                             return nil, nil
//                     } () >>
//                | TypeSpec RepeatTerminator
//                     << func() (Attrib, error) {
//                             fmt.Println("TypeSpec RepeatTerminator");
//                             return nil, nil
//                     } () >>
//                ;
//
TypeSpec
        : TypeDef  << ast.NewNode($0) >>
//          |    AliasDecl
//             << func() (Attrib, error) {
//                     fmt.Println("AliasDecl");
//                     return nil, nil
//             } () >>
//          | empty
//             << func() (Attrib, error) {
//                     fmt.Println("empty");
//                     return nil, nil
//             } () >>
        ;
//
// AliasDecl : identifier "=" Type
//             << func() (Attrib, error) {
//                     fmt.Println("identifier \"=\" Type");
//                     return nil, nil
//             } () >>
//           ;

TypeDef
        : identifier Type  << ast.NewTypeDef($0, $1) >>
        ;

// --- [ Constant declarations ] -----------------------------------------------

// ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
// ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .
// IdentifierList = identifier { "," identifier } .
// ExpressionList = Expression { "," Expression } .
ConstDecl
        : kwdConst ConstSpec  << ast.InitNode("", $1.(*ast.Node).Code) >>
          // | kwdConst "(" RepeatTerminator RepeatConstSpec ")"
          //   << func() (Attrib, error) {
          //           fmt.Println("kwdConst \"(\" RepeatTerminator RepeatConstSpec \")\"");
          //           return nil, nil
          //   } () >>
        ;

// RepeatConstSpec : ConstSpec terminator RepeatTerminator RepeatConstSpec
//                 << func() (Attrib, error) {
//                       fmt.Println("ConstSpec terminator RepeatTerminator RepeatConstSpec");
//                       return nil, nil
//                 } () >>
//                 | ConstSpec RepeatTerminator
//                 << func() (Attrib, error) {
//                       fmt.Println("ConstSpec RepeatTerminator");
//                       return nil, nil
//                 } () >>
//                 ;

ConstSpec
        : IdentifierList                     << ast.NewConstSpec(0, $0) >>
        | IdentifierList "=" ExpressionList  << ast.NewConstSpec(1, $0, $2) >>
          // | IdentifierList Type "=" ExpressionList
          //       << func() (Attrib, error) {
          //               fmt.Println("IdentifierList Type \"=\" ExpressionList");
          //               return nil, nil
          //       } () >>
          // | empty
          //       << func() (Attrib, error) {
          //               fmt.Println("empty");
          //               return nil, nil
          //       } () >>
        ;

// --- [ Expressions ] ---------------------------------------------------------

ExpressionList
        : Expression                     << ast.NewExpr($0) >>
        | Expression "," ExpressionList  << ast.AppendExpr($0, $2) >>
        ;

// Expression = UnaryExpr | Expression binary_op Expression .
// NOTE: The original BNF corresponding to Expression is modified to take into
// account operator precedence. The operators used are in the order of
// increasing precedence starting from top.
Expression
        : Expression "||" Term1  << ast.NewBoolExpr($1, $0, $2) >>
        | Term1                  << ast.NewExpr($0) >>
        ;

Term1
        : Term1 "&&" Term2  << ast.NewBoolExpr($1, $0, $2) >>
        | Term2             << ast.NewExpr($0) >>
        ;

Term2
        : Term2 RelOp Term3  << ast.NewRelExpr($1, $0, $2) >>
        | Term3              << ast.NewExpr($0) >>
        ;

Term3
        : Term3 "+" Term4  << ast.NewArithExpr($1, $0, $2) >>
        | Term4            << ast.NewExpr($0) >>
        ;

Term4
        : Term4 "-" Term5  << ast.NewArithExpr($1, $0, $2) >>
        | Term5            << ast.NewExpr($0) >>
        ;

Term5
        : Term5 "*" Term6  << ast.NewArithExpr($1, $0, $2) >>
        | Term6            << ast.NewExpr($0) >>
        ;

Term6
        : Term6 "/" Term7  << ast.NewArithExpr($1, $0, $2) >>
        | Term7            << ast.NewExpr($0) >>
        ;

Term7
        : Term7 "%" Term8  << ast.NewArithExpr($1, $0, $2) >>
        | Term8            << ast.NewExpr($0) >>
        ;

Term8
        : "(" Expression ")"  << ast.NewExpr($1) >>
        | UnaryExpr           << ast.NewExpr($0) >>
        ;

// TODO: Add support for booleans in IR.
BinaryOp
        : RelOp  << ast.InitNode($0.(*ast.Node).Place, []string{}) >>
        | "||"   << ast.InitNode("or", []string{}) >>
        | "&&"   << ast.InitNode("and", []string{}) >>
        ;

// unaryOp will be used for defining UnaryExpr in parser.
// unaryOp     : '+' | '-' | '!' | '^' | '*' | '&' | '<' '-' ;
// binaryOp    : '|' '|' | '&' '&' | _relOp | _addOp | _mulOp ;
RelOp
        : "=="  << ast.InitNode("==", []string{}) >>
        | "!="  << ast.InitNode("!=", []string{}) >>
        | "<="  << ast.InitNode("<=", []string{}) >>
        | "<"   << ast.InitNode("<", []string{}) >>
        | ">="  << ast.InitNode(">=", []string{}) >>
        | ">"   << ast.InitNode(">", []string{}) >>
        ;

// UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .
UnaryExpr
        : PrimaryExpr        << ast.NewNode($0) >>
        | UnaryOp UnaryExpr  << ast.NewUnaryExpr($0, $1) >>
        ;

UnaryOp
        : "+"  << ast.InitNode("+", []string{}) >>
        | "-"  << ast.InitNode("-", []string{}) >>
        | "!"  << ast.InitNode("!", []string{}) >>
//         | "^"
//               << func() (Attrib, error) {
//                     fmt.Println("\"^\"");
//                     return nil, nil
//               } () >>
        | "*"  << ast.InitNode("*", []string{}) >>
        | "&"  << ast.InitNode("&", []string{}) >>
//         | "<-"
//               << func() (Attrib, error) {
//                     fmt.Println("\"<-\"");
//                     return nil, nil
//               } () >>
        ;

// PrimaryExpr =
//  Operand |
//  Conversion |
//  MethodExpr |
//  PrimaryExpr Selector |
//  PrimaryExpr Index |
//  PrimaryExpr Slice |
//  PrimaryExpr TypeAssertion |
//  PrimaryExpr Arguments .
PrimaryExpr
        : Operand  << ast.NewNode($0) >>
//             | Conversion
//                 << func() (Attrib, error) {
//                       fmt.Println("Conversion");
//                       return nil, nil
//                 } () >>
        | PrimaryExpr Selector  << ast.NewPrimaryExprSel($0, $1) >>
        | PrimaryExpr Index     << ast.NewPrimaryExprIndex($0, $1) >>
//             | PrimaryExpr Slice
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr Slice");
//                       return nil, nil
//                 } () >>
//             | PrimaryExpr TypeAssertion
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr TypeAssertion");
//                       return nil, nil
//                 } () >>
        | PrimaryExpr Arguments  << ast.NewPrimaryExprArgs($0, $1) >>
        ;

// Operand     = Literal | OperandName | "(" Expression ")" .
// Literal     = BasicLit | CompositeLit | FunctionLit .
// BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
// OperandName = identifier | QualifiedIdent.
Operand
        : Literal      << ast.NewNode($0) >>
        | OperandName  << ast.InitNode($0.(*ast.Node).Place, []string{}) >>
//         | "(" Expression ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Expression \")\"");
//                       return nil, nil
//                 } () >>
        ;

Literal
        : BasicLit      << ast.InitNode($0.(*ast.Node).Place, []string{}) >>
        | CompositeLit  << ast.NewNode($0) >>
//         | FunctionLit
//                 << func() (Attrib, error) {
//                       fmt.Println("FunctionLit");
//                       return nil, nil
//                 } () >>
        ;

BasicLit
        : intLit  << ast.InitNode(string($0.(*token.Token).Lit), []string{}) >>
//          | floatLit
//                 << func() (Attrib, error) {
//                       fmt.Println("floatLit");
//                       return nil, nil
//                 } () >>
//          | runeLit
//                 << func() (Attrib, error) {
//                       fmt.Println("runeLit");
//                       return nil, nil
//                 } () >>
        | stringLit  << ast.InitNode(fmt.Sprintf("string:%s", string($0.(*token.Token).Lit)), []string{}) >>
//          | boolLit
//                << func() (Attrib, error) {
//                      fmt.Println("boolLit");
//                      return nil, nil
//                } () >>
        ;

// CompositeLit  = LiteralType LiteralValue .
// LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
//                 SliceType | MapType | TypeName .
// LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
// ElementList   = KeyedElement { "," KeyedElement } .
// KeyedElement  = [ Key ":" ] Element .
// Key           = FieldName | Expression | LiteralValue .
// FieldName     = identifier .
// Element       = Expression | LiteralValue .
CompositeLit
        : LiteralType LiteralValue  << ast.NewCompositeLit($0, $1) >>
        ;

LiteralType
        : ArrayType  << ast.InitNode($0.(*ast.Node).Place, []string{}) >>
            // | StructType
            //             << func() (Attrib, error) {
            //                     return Node{$0.(*ast.Node).Place, []string{}}, nil
            //             } () >>
            // | "[" "..." "]" ElementType
//                     << func() (Attrib, error) {
//                           fmt.Println("\"[\" \"...\" \"]\" ElementType");
//                           return nil, nil
//                     } () >>
//
//             | SliceType
//                   << func() (Attrib, error) {
//                         fmt.Println("SliceType");
//                         return nil, nil
//                   } () >>
//             | type
//                   << func() (Attrib, error) {
//                         fmt.Println("type");
//                         return nil, nil
//                   } () >>
            // When initializing structs, TypeName will be used as the name of struct.
        | TypeName  << ast.NewNode($0) >>
        ;

// TypeName  = identifier | QualifiedIdent .
// QualifiedIdent = PackageName "." identifier .
TypeName
        : identifier  << ast.InitNode(string($0.(*token.Token).Lit), []string{}) >>
         // | type
        ;

LiteralValue
        : "{" RepeatTerminator "}"  << ast.InitNode("", []string{}) >>
        // NOTE: We don't support adding a ',' after the last KeyedElement
        // as opposed to the official go language.
        // TODO: Support for struct initialization.
        | "{" RepeatTerminator ElementList "}"  << ast.NewNode($2) >>
        ;

ElementList
        : KeyedElement RepeatKeyedElement  << ast.NewElementList($0, $1) >>
        ;

RepeatKeyedElement
        : "," RepeatTerminator KeyedElement RepeatKeyedElement
                            << ast.AppendKeyedElement($2, $3) >>
        | RepeatTerminator  << ast.InitNode("", []string{}) >>
//                    // | "," RepeatTerminator
//                    //      << func() (Attrib, error) {
//                    //            fmt.Println("\",\" RepeatTerminator");
//                    //            return nil, nil
//                    //      } () >>
//                    // | empty
//                    //      << func() (Attrib, error) {
//                    //            fmt.Println("empty");
//                    //            return nil, nil
//                    //      } () >>
        ;

KeyedElement
        : Element  << ast.NewNode($0) >>
//              | Key ":" Element
//                 << func() (Attrib, error) {
//                         fmt.Println("Key \":\" Element");
//                         return nil, nil
//                 } () >>
        ;

// Key : FieldName
//         << func() (Attrib, error) {
//               fmt.Println("FieldName");
//               return nil, nil
//         } () >>
//     | Expression
//         << func() (Attrib, error) {
//               fmt.Println("Expression");
//               return nil, nil
//         } () >>
//     | LiteralValue
//         << func() (Attrib, error) {
//               fmt.Println("LiteralValue");
//               return nil, nil
//         } () >>
//     ;
//
// FieldName : identifier
//                 << func() (Attrib, error) {
//                       fmt.Println("identifier");
//                       return nil, nil
//                 } () >>
//          ;

Element
        : Expression  << ast.NewNode($0) >>
//         | LiteralValue
//                 << func() (Attrib, error) {
//                       fmt.Println("LiteralValue");
//                       return nil, nil
//                 } () >>
        ;

// // FunctionLit = "func" Signature FunctionBody .
// FunctionLit : kwdFunc Signature FunctionBody
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFunc Signature FunctionBody");
//                       return nil, nil
//                 } () >>
//             ;

OperandName
        : identifier  << ast.NewIdentifier($0) >>
        ;

// Selector       = "." identifier .
// Index          = "[" Expression "]" .
// Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
//                  "[" [ Expression ] ":" Expression ":" Expression "]" .
// TypeAssertion  = "." "(" Type ")" .
// Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
// Conversion = Type "(" Expression [ "," ] ")"
Selector
        : "." identifier  << ast.InitNode(string($1.(*token.Token).Lit), []string{}) >>
        ;

Index
        : "[" Expression "]"  << ast.NewNode($1) >>
        ;

// Slice : "[" ":" "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" ":" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       ;
//
// TypeAssertion : "." "(" Type ")"
//               << func() (Attrib, error) {
//                     fmt.Println("\".\" \"(\" Type \")\"");
//                     return nil, nil
//               } () >>
//               ;

// Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
// NOTE: Since compilation of local variables has not yet been done, only empty
// arguments are supported for the time being.
Arguments
        : "(" ")"                 << ast.InitNode("", []string{}) >>
        | "(" ExpressionList ")"  << ast.NewNode($1) >>
//           | "(" ExpressionList "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
        ;

// Conversion : Type "(" Expression ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("Type \"(\" Expression \")\"");
//                       return nil, nil
//                 } () >>
//            | Type "(" Expression "," ")"
//                << func() (Attrib, error) {
//                      fmt.Println("Type \"(\" Expression \",\" \")\"");
//                      return nil, nil
//                } () >>
//            ;

// FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
// FunctionName = identifier .
// FunctionBody = Block .
// NOTE: To support recursion, we need to add function's symbol table entry before
// the production rule for block of its body is reached. This is to avoid errors
// of the form "funcion not declared". A marker is introduced for the same.
FunctionDecl
        : FunctionMarker FunctionBody  << ast.NewFuncDecl($0, $1) >>
        // TODO Handle function declarations without body.
        // | kwdFunc FunctionName Signature
        ;

FunctionMarker
        : kwdFunc FunctionName Signature  << ast.NewFuncMarker($1, $2) >>
        ;

// Signature      = Parameters [ Result ] .
// Result         = Parameters | Type .
// Parameters     = "(" [ ParameterList [ "," ] ] ")" .
// ParameterList  = ParameterDecl { "," ParameterDecl } .
// ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
Signature
        : Parameters         << ast.NewSignature(0, $0) >>
        | Parameters Result  << ast.NewSignature(1, $0, $1) >>
        ;

Result
        : Parameters  << ast.NewResult($0) >>
        | Type        << ast.InitNode("1", []string{}) >>
        ;

// TODO: Ignore terminator
// TODO: Parameters cannot end in ','
Parameters
        : "(" RepeatTerminator ")"  << ast.InitNode("", []string{}) >>
        | "(" ParameterList ")"     << ast.InitNode("", $1.(*ast.Node).Code) >>
        ;

ParameterList
        : ParameterDecl RepeatParameterDecl  << ast.NewParamList($0, $1) >>
        ;

RepeatParameterDecl
        : "," ParameterDecl RepeatParameterDecl  << ast.AppendParam($1, $2) >>
        | empty                                  << ast.InitNode("", []string{}) >>
        ;

ParameterDecl
        : IdentifierList Type  << ast.InitNode("", $0.(*ast.Node).Code) >>
        | Type                 << ast.InitNode("", []string{fmt.Sprintf("int")}) >>
//                 | "..." Type
//                 << func() (Attrib, error) {
//                       fmt.Println("\"...\" Type");
//                       return nil, nil
//                 } () >>
//                 | IdentifierList "..." Type
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList \"...\" Type");
//                       return nil, nil
//                 } () >>
              ;

// Type      = TypeName | TypeLit | "(" Type ")" .
// TypeName  = identifier | QualifiedIdent .
// TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
//             SliceType | MapType | ChannelType .
Type
        : type  << ast.InitNode(string($0.(*token.Token).Lit), []string{}) >>
//       | identifier
//         << func() (Attrib, error) {
//                 fmt.Println("identifier");
//                 return nil, nil
//         } () >>
        | TypeLit  << ast.NewNode($0) >>
//       | "(" Type ")"
//         << func() (Attrib, error) {
//               fmt.Println("\"(\" Type \")\"");
//               return nil, nil
//         } () >>
        ;

TypeLit
        : StructType  << ast.InitNode("struct", $0.(*ast.Node).Code) >>
        // | ArrayType
        // << func() (Attrib, error) {
        //       fmt.Println("StructType");
        //       return nil, nil
        // } () >>
//         | PointerType
//         << func() (Attrib, error) {
//               fmt.Println("PointerType");
//               return nil, nil
//         } () >>
//         | FunctionType
//         << func() (Attrib, error) {
//               fmt.Println("FunctionType");
//               return nil, nil
//         } () >>
//         | SliceType
//         << func() (Attrib, error) {
//               fmt.Println("SliceType");
//               return nil, nil
//         } () >>
        ;

// ArrayType   = "[" ArrayLength "]" ElementType .
// ArrayLength = Expression .
// ElementType = Type .
// TODO: ElementType is taken to be only int for now.
ArrayType
        : "[" ArrayLength "]" ElementType
                << ast.InitNode(fmt.Sprintf("array:%s", $1.(*ast.Node).Place), []string{}) >>
        ;

// NOTE: ArrayLength is modified to be only an integer, unlike in Go where it is
// an expression.
ArrayLength
        : intLit  << ast.InitNode(string($0.(*token.Token).Lit), []string{}) >>
        ;

ElementType
        : Type  << ast.InitNode($0.(*ast.Node).Place, []string{}) >>
        ;

// StructType    = kwdStruct "{" { FieldDecl ";" } "}" .
// FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
// EmbeddedField = [ "*" ] TypeName .
// Tag           = string_lit .
StructType
        : kwdStruct RepeatTerminator "{" RepeatTerminator RepeatFieldDecl "}"
                << ast.InitNode("", $4.(*ast.Node).Code) >>
        ;

RepeatFieldDecl
        : FieldDecl terminator RepeatTerminator RepeatFieldDecl
                                      << ast.AppendFieldDecl($0, $3) >>
        | FieldDecl RepeatTerminator  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

FieldDecl
        : IdentifierList Type  << ast.NewFieldDecl($0, $1) >>
//           | IdentifierList Type Tag
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList Type Tag");
//                       return nil, nil
//                 } () >>
//           | EmbeddedField
//                 << func() (Attrib, error) {
//                       fmt.Println("EmbeddedField");
//                       return nil, nil
//                 } () >>
//           | EmbeddedField Tag
//                 << func() (Attrib, error) {
//                       fmt.Println("EmbeddedField Tag");
//                       return nil, nil
//                 } () >>
        | empty  << ast.InitNode("", []string{}) >>
        ;

// EmbeddedField : type
//                 << func() (Attrib, error) {
//                       fmt.Println("type");
//                       return nil, nil
//                 } () >>
//               | "*" type
//                 << func() (Attrib, error) {
//                       fmt.Println("\"*\" type");
//                       return nil, nil
//                 } () >>
//               ;
//
// Tag : stringLit
//         << func() (Attrib, error) {
//               fmt.Println("stringLit");
//               return nil, nil
//         } () >>
//     ;
//
// // PointerType = "*" BaseType .
// // BaseType    = Type .
// PointerType : "*" BaseType
//                 << func() (Attrib, error) {
//                       fmt.Println("\"*\" BaseType");
//                       return nil, nil
//                 } () >>
//             ;
//
// BaseType : Type
//                 << func() (Attrib, error) {
//                       fmt.Println("Type");
//                       return nil, nil
//                 } () >>
//          ;
//
// // FunctionType   = "func" Signature .
// // Signature      = Parameters [ Result ] .
// // Result         = Parameters | Type .
// // Parameters     = "(" [ ParameterList [ "," ] ] ")" .
// // ParameterList  = ParameterDecl { "," ParameterDecl } .
// // ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
// FunctionType : kwdFunc Signature
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFunc Signature");
//                       return nil, nil
//                 } () >>
//              ;
//
// // SliceType = "[" "]" ElementType .
// SliceType : "[" "]" ElementType
//                 << func() (Attrib, error) {
//                       fmt.Println("\"[\" \"]\" ElementType");
//                       return nil, nil
//                 } () >>
//           ;

// IdentifierList = identifier { "," identifier } .
IdentifierList
        : identifier                     << ast.InitNode("", []string{string($0.(*token.Token).Lit)}) >>
        | identifier "," IdentifierList  << ast.AppendIdent($0, $2) >>
        ;

// The symbol table entry for a function is of the form -
//      functionName : ["func", (rest of the values are yet to be decided)]
FunctionName
        : identifier  << ast.InitNode(string($0.(*token.Token).Lit), []string{}) >>
        ;

FunctionBody
        : Block  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

RepeatTerminator
        : terminator RepeatTerminator
        | empty
        ;

// --- [ Statements ] ----------------------------------------------------------

StatementList
        : Statement terminator RepeatTerminator StatementList
                                      << ast.NewStmtList($0, $3) >>
        | Statement RepeatTerminator  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

// Statement = Declaration | LabeledStmt | SimpleStmt |
//             GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
//             FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
//             DeferStmt .
// NOTE: The following additional statements are introduced.
// PrintIntStmt
Statement
        : Declaration   << ast.InitNode("", $0.(*ast.Node).Code) >>
        | LabeledStmt   << ast.InitNode("", $0.(*ast.Node).Code) >>
        | SimpleStmt    << ast.InitNode("", $0.(*ast.Node).Code) >>
        | ReturnStmt    << ast.InitNode("", $0.(*ast.Node).Code) >>
        | BreakStmt     << ast.InitNode("", $0.(*ast.Node).Code) >>
        | ContinueStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
        | GotoStmt      << ast.InitNode("", $0.(*ast.Node).Code) >>
        | Block         << ast.InitNode("", $0.(*ast.Node).Code) >>
        | IfStmt        << ast.InitNode("", $0.(*ast.Node).Code) >>
        | SwitchStmt    << ast.InitNode("", $0.(*ast.Node).Code) >>
        | ForStmt       << ast.InitNode("", $0.(*ast.Node).Code) >>
        | DeferStmt     << ast.InitNode("", $0.(*ast.Node).Code) >>
        | PrintStmt     << ast.InitNode("", $0.(*ast.Node).Code) >>
        | ScanStmt      << ast.InitNode("", $0.(*ast.Node).Code) >>
        // TODO: FallthroughStmt is not supported currently.
        ;

// LabeledStmt = Label ":" Statement .
// Label       = identifier .
LabeledStmt
        : Label ":" RepeatTerminator Statement  << ast.NewLabelStmt($0, $3) >>
        ;

// SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
// EmptyStmt = .
// ExpressionStmt = Expression .
// IncDecStmt = Expression ( "++" | "--" ) .
// Assignment = ExpressionList assign_op ExpressionList .
// assign_op = [ add_op | mul_op ] "=" .
// ShortVarDecl = IdentifierList ":=" ExpressionList .
SimpleStmt
        : EmptyStmt       << ast.InitNode("", []string{}) >>
        | Assignment      << ast.InitNode("", $0.(*ast.Node).Code) >>
        | ShortVarDecl    << ast.InitNode("", $0.(*ast.Node).Code) >>
        | IncDecStmt      << ast.InitNode("", $0.(*ast.Node).Code) >>
        | ExpressionStmt  << ast.NewNode($0) >>
//            | Assignment
//                << func() (Attrib, error) {
//                      fmt.Println("Assignment");
//                      return nil, nil
//                } () >>
//            | ShortVarDecl
//                << func() (Attrib, error) {
//                      fmt.Println("ShortVarDecl");
//                      return nil, nil
//                } () >>
//            | EmptyStmt
//                << func() (Attrib, error) {
//                      fmt.Println("EmptyStmt");
//                      return nil, nil
//                } () >>
        ;

EmptyStmt : empty ;

ReturnStmt
        : kwdRet                 << ast.NewReturnStmt() >>
        | kwdRet ExpressionList  << ast.NewReturnStmt($1) >>
        ;

// BreakStmt = "break" [ Label ] .
BreakStmt
        : kwdBreak        << ast.InitNode("", []string{"break"}) >>
        | kwdBreak Label  << ast.InitNode("", []string{fmt.Sprintf("j, %s", $1.(*ast.Node).Place)}) >>
        ;

// ContinueStmt = "continue" [ Label ] .
ContinueStmt
        : kwdContinue  << ast.InitNode("", []string{"continue"}) >>
        // TODO: `continue label` vs `break label` ??
        // | kwdContinue Label
        //    << func() (Attrib, error) {
        //          fmt.Println("kwdContinue Label");
        //          return nil, nil
        //    } () >>
        ;

// GotoStmt = "goto" Label .
GotoStmt
        : kwdGoto Label  << ast.InitNode("", []string{fmt.Sprintf("j, %s", $1.(*ast.Node).Place)}) >>
        ;

Block
        : "{" Marker RepeatTerminator StatementList "}"  << ast.NewBlock($3) >>
        ;

// NOTE: Marker demarcates the beginning of a block and the corresponding symbol
// table is instantiated here.
Marker
        : empty  << ast.NewBlockMarker() >>
        ;

// IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
IfStmt
        : kwdIf Expression Block                        << ast.NewIfStmt(0, $1, $2) >>
        | kwdIf Expression Block kwdElse Block          << ast.NewIfStmt(1, $1, $2, $4) >>
        | kwdIf Expression Block kwdElse IfStmt         << ast.NewIfStmt(2, $1, $2, $4) >>
        | kwdIf SimpleStmt terminator Expression Block  << ast.NewIfStmt(3, $1, $3, $4) >>
        | kwdIf SimpleStmt terminator Expression Block kwdElse IfStmt
                                                        << ast.NewIfStmt(4, $1, $3, $4, $6) >>
        | kwdIf SimpleStmt terminator Expression Block kwdElse Block
                                                        << ast.NewIfStmt(5, $1, $3, $4, $6) >>
        ;

// SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
SwitchStmt
        : ExprSwitchStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
//            | TypeSwitchStmt
//                << func() (Attrib, error) {
//                      fmt.Println("TypeSwitchStmt");
//                      return nil, nil
//                } () >>
        ;

// ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
// ExprCaseClause = ExprSwitchCase ":" StatementList .
// ExprSwitchCase = "case" ExpressionList | "default" .
ExprSwitchStmt
        : kwdSwitch Expression "{" RepeatTerminator RepeatExprCaseClause "}"  << ast.NewSwitchStmt($1, $4) >>
        // TODO: Handle empty expression
//                | kwdSwitch "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch Expression \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch SimpleStmt terminator "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch SimpleStmt terminator \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch SimpleStmt terminator Expression "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch SimpleStmt terminator Expression \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
        ;

RepeatExprCaseClause
        : ExprCaseClause RepeatExprCaseClause  << ast.AppendExprCaseClause($0, $1) >>
        | empty                                << ast.InitNode("", []string{}) >>
        ;

// ExprCaseClause = ExprSwitchCase ":" StatementList .
// ExprSwitchCase = "case" ExpressionList | "default" .
ExprCaseClause
        : ExprSwitchCase ":" RepeatTerminator StatementList
                << ast.NewExprCaseClause($0, $3) >>
        ;

// NOTE: The grammar is modified to support only a single expression in a
// switch statement.
// ExprSwitchCase : kwdCase ExpressionList
ExprSwitchCase
        : kwdCase Expression  << ast.NewNode($1) >>
        | kwdDefault          << ast.InitNode("default", []string{}) >>
        ;

// // TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
// // TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
// // TypeCaseClause  = TypeSwitchCase ":" StatementList .
// // TypeSwitchCase  = "case" TypeList | "default" .
// // TypeList        = Type { "," Type } .
// TypeSwitchStmt : kwdSwitch TypeSwitchGuard "{" RepeatTerminator RepeatTypeCaseClause "}"
//                       << func() (Attrib, error) {
//                             fmt.Println("kwdSwitch TypeSwitchGuard \"{\" RepeatTerminator RepeatTypeCaseClause \"}\"");
//                             return nil, nil
//                       } () >>
//                | kwdSwitch SimpleStmt terminator TypeSwitchGuard "{" RepeatTerminator RepeatTypeCaseClause "}"
//                      << func() (Attrib, error) {
//                            fmt.Println("kwdSwitch SimpleStmt terminator TypeSwitchGuard \"{\" RepeatTerminator RepeatTypeCaseClause \"}\"");
//                            return nil, nil
//                      } () >>
//                ;
//
// RepeatTypeCaseClause : TypeCaseClause RepeatTypeCaseClause
//                     << func() (Attrib, error) {
//                           fmt.Println("TypeCaseClause RepeatTypeCaseClause");
//                           return nil, nil
//                     } () >>
//                      | empty
//                      << func() (Attrib, error) {
//                            fmt.Println("empty");
//                            return nil, nil
//                      } () >>
//                      ;
//
// TypeSwitchGuard : PrimaryExpr "." "(" kwdType ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr \".\" \"(\" kwdType \")\"");
//                       return nil, nil
//                 } () >>
//                 | identifier shortAssign PrimaryExpr "." "(" kwdType ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("identifier shortAssign PrimaryExpr \".\" \"(\" kwdType \")\"");
//                       return nil, nil
//                 } () >>
//                 ;
//
// TypeCaseClause : TypeSwitchCase ":" StatementList
//                 << func() (Attrib, error) {
//                       fmt.Println("TypeSwitchCase \":\" StatementList");
//                       return nil, nil
//                 } () >>
//                ;
//
// TypeSwitchCase : kwdCase TypeList
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdCase TypeList");
//                       return nil, nil
//                 } () >>
//                | kwdDefault
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdDefault");
//                       return nil, nil
//                 } () >>
//                ;
//
// TypeList : Type RepeatType
//                 << func() (Attrib, error) {
//                       fmt.Println("Type RepeatType");
//                       return nil, nil
//                 } () >>
//          ;
//
// RepeatType : "," Type RepeatType
//                 << func() (Attrib, error) {
//                       fmt.Println("\",\" Type RepeatType");
//                       return nil, nil
//                 } () >>
//            | empty
//                 << func() (Attrib, error) {
//                       fmt.Println("empty");
//                       return nil, nil
//                 } () >>
//            ;

// ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
// Condition = Expression .
ForStmt
        : kwdFor Block            << ast.NewForStmt(0, $1) >>
        | kwdFor Condition Block  << ast.NewForStmt(1, $1, $2) >>
        | kwdFor ForClause Block  << ast.NewForStmt(2, $1, $2) >>
//         | kwdFor RangeClause Block
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFor RangeClause Block");
//                       return nil, nil
//                 } () >>
        ;

// // RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
// RangeClause : kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             | ExpressionList "=" kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("ExpressionList \"=\" kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             | IdentifierList shortAssign kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList shortAssign kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             ;

// ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
// InitStmt = SimpleStmt .
// PostStmt = SimpleStmt .
// NOTE: The place value of ForClause contains the place value of the condition
// statement as that will be required in ForStmt to determine when to break. The
// place values of InitStmt and PostStmt will not be required.
// The code value of ForClause contains newline separated codes of InitStmt,
// Condition and PostStmt.
// When Condition is not specified, do an endless loop by initializing the place
// value to 1.
ForClause
        : terminator terminator  << ast.InitNode("1", []string{"", "", ""}) >>
        | InitStmt terminator terminator            << ast.NewForClause(0, $0) >>
        | terminator Condition terminator           << ast.NewForClause(1, $1) >>
        | terminator terminator PostStmt            << ast.NewForClause(2, $2) >>
        | InitStmt terminator Condition terminator  << ast.NewForClause(3, $0, $2) >>
        | InitStmt terminator terminator PostStmt   << ast.NewForClause(4, $0, $3) >>
        | terminator Condition terminator PostStmt  << ast.NewForClause(5, $1, $3) >>
        | InitStmt terminator Condition terminator PostStmt
                                                    << ast.NewForClause(6, $0, $2, $4) >>
        ;

InitStmt
        : SimpleStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

PostStmt
        : SimpleStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

// FIXME: Condition can only be a binary expression.
Condition
        : Expression  << ast.NewNode($0) >>
        ;

// DeferStmt = "defer" Expression .
// NOTE: Currently defer only handles function calls and not method calls.
DeferStmt
        : "defer" PrimaryExpr Arguments  << ast.NewDeferStmt($1, $2) >>
        ;

PrintStmt
        : PrintIntStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
        | PrintStrStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

ScanStmt
        : ScanIntStmt  << ast.InitNode("", $0.(*ast.Node).Code) >>
        ;

PrintIntStmt
        : "printInt" Expression  << ast.NewIOStmt($0, $1) >>
        ;

PrintStrStmt
        : "printStr" Expression  << ast.NewIOStmt($0, $1) >>
        ;

ScanIntStmt
        : "scanInt" Expression  << ast.NewIOStmt($0, $1) >>
        ;

ExpressionStmt
        : Expression  << ast.NewNode($0) >>
        ;

IncDecStmt
        : Expression "++"  << ast.NewIncDecStmt($1, $0) >>
        | Expression "--"  << ast.NewIncDecStmt($1, $0) >>
        ;

Assignment
        : ExpressionList assignOp ExpressionList  << ast.NewAssignStmt(0, $1, $0, $2) >>
        | ExpressionList "=" ExpressionList       << ast.NewAssignStmt(1, $1, $0, $2) >>
        | IdentifierList "=" ExpressionList       << ast.NewAssignStmt(2, $1, $0, $2) >>
        ;

ShortVarDecl
        : IdentifierList shortAssign ExpressionList  << ast.NewShortDecl($0, $2) >>
        ;

Label
        : identifier  << ast.InitNode(string($0.(*token.Token).Lit), []string{}) >>
        ;
